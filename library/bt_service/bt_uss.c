/** @file user_settings_bt_service.c
 *
 * @brief Bluetooth service for user settings
 *
 * @par
 * COPYRIGHT NOTICE: (c) 2023 Irnas. All rights reserved.
 */

#include <bt_uss.h>

#include <zephyr/types.h>
#include <bluetooth/gatt.h>
#include <bluetooth/uuid.h>
#include <logging/log.h>

#include <user_settings_list.h>
#include <user_settings_protocol_types.h>

#include <user_settings_protocol_binary.h>
#include <user_settings_protocol_executor.h>

LOG_MODULE_REGISTER(bt_sds, CONFIG_USER_SETTINGS_BT_SERVICE_LOG_LEVEL);

/** UUID of the USS service */
#define BT_UUID_USS_VAL	     BT_UUID_128_ENCODE(0x8467a290, 0x5ac0, 0x4856, 0xb3bc, 0x85ae11a5bd81)
/** UUID of the USS characteristic */
#define BT_UUID_USS_CHAR_VAL BT_UUID_128_ENCODE(0x8467a291, 0x5ac0, 0x4856, 0xb3bc, 0x85ae11a5bd81)

#define BT_UUID_USS_SERVICE BT_UUID_DECLARE_128(BT_UUID_USS_VAL)
#define BT_UUID_USS_CHAR    BT_UUID_DECLARE_128(BT_UUID_USS_CHAR_VAL)

/* Forward declared notify function */
static int prv_send_notification(uint8_t *data, size_t len);

/* Save connection that is using the settings service so a notification can be sent to it */
static struct bt_conn *prv_bt_conn;

/* Response buffer and binary protocol executor */
static uint8_t prv_resp_buffer[512];
static struct usp_executor prv_usp_binary_executor = USP_BINARY_EXECUTOR_DECLARE(
	prv_resp_buffer, sizeof(prv_resp_buffer), prv_send_notification);

/**
 * @brief Data written into the characteristic by the client is received in this callback
 *
 * The data received will be parsed using the user settings binary protocol.
 * Any respones generated by the protocol executor will be sent as notifications to the connected
 * device.
 *
 * @param[in] conn The connection object
 * @param[in] attr The GATT attribute
 * @param[in] buf The buffer received
 * @param[in] len The length of the buffer
 * @param[in] offset Target buffer offset
 * @param[in] flags Write flags of the client device
 *
 * @return ssize_t Number of bytes written, or in case of an error
 *          BT_GATT_ERR() with a specific ATT error code.
 */
static ssize_t prv_on_receive_write(struct bt_conn *conn, const struct bt_gatt_attr *attr,
				    const void *buf, uint16_t len, uint16_t offset, uint8_t flags)
{
	LOG_DBG("Received data, handle %d, conn %p", attr->handle, (void *)conn);

	/* decode and execute */
	int err = usp_executor_parse_and_execute(&prv_usp_binary_executor, (uint8_t *)buf, len);
	if (!err) {
		return len;
	}

	LOG_DBG("usp_executor_parse_and_execute, err: %d", err);
	switch (err) {
	case -ENOENT:
		return BT_GATT_ERR(BT_ATT_ERR_ATTRIBUTE_NOT_FOUND);
	case -EPROTO:
		return BT_GATT_ERR(BT_ATT_ERR_NOT_SUPPORTED);
	default:
		return BT_GATT_ERR(BT_ATT_ERR_UNLIKELY);
	}
}

/* clang-format off */
BT_GATT_SERVICE_DEFINE(prv_uss_service,
	BT_GATT_PRIMARY_SERVICE(BT_UUID_USS_SERVICE),
	BT_GATT_CHARACTERISTIC(BT_UUID_USS_CHAR,
			       BT_GATT_CHRC_NOTIFY | BT_GATT_CHRC_WRITE,
			       BT_GATT_PERM_WRITE, NULL, prv_on_receive_write, NULL),
	BT_GATT_CCC(NULL, BT_GATT_PERM_READ | BT_GATT_PERM_WRITE),
);
/* clang-format on */

/**
 * @brief Send data as a notification
 *
 * The data will be sent if the connected device is subscribed to notifications.
 * An error is returned otherwise
 *
 * @param[in] data The data to send
 * @param[in] len The length of the data, in bytes
 *
 * @retval 0 on success
 * @retval -ENOTCONN if the connected device is not subscribed to notifications
 * @retval -EIO if sending the notification fails
 */
static int prv_send_notification(uint8_t *data, size_t len)
{
	int ret;

	if (!prv_bt_conn) {
		return -ENOTCONN;
	}

	const struct bt_gatt_attr *attr = &prv_uss_service.attrs[2];

	if (!bt_gatt_is_subscribed(prv_bt_conn, attr, BT_GATT_CCC_NOTIFY)) {
		return -ENOTCONN;
	}

	ret = bt_gatt_notify(prv_bt_conn, attr, data, len);
	if (ret < 0) {
		return -EIO;
	}

	return 0;
}

void bt_uss_enable(struct bt_conn *conn)
{
	prv_bt_conn = bt_conn_ref(conn);
}

void bt_uss_disable(struct bt_conn *conn)
{
	bt_conn_unref(prv_bt_conn);
	prv_bt_conn = NULL;
}
